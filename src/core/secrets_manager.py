"""Secure secrets management with encryption and platform-specific key storage."""

import json
import logging
import platform
import threading
from pathlib import Path
from typing import Dict, Optional, List
from cryptography.fernet import Fernet

logger = logging.getLogger(__name__)

# Thread lock for atomic operations
_secrets_lock = threading.Lock()


class SecretsManager:
    """Manages encrypted secrets storage with platform-specific key management."""
    
    def __init__(self, project_root: Optional[Path] = None):
        """
        Initialize secrets manager.
        
        Args:
            project_root: Project root directory (default: current directory)
        """
        if project_root is None:
            project_root = Path.cwd()
        self.project_root = Path(project_root).resolve()
        self.secrets_file = self.project_root / ".secrets.devforge"
        self.key_manager = _KeyManager()
    
    def init_store(self) -> bool:
        """
        Initialize secrets store.
        
        Returns:
            True if store was created, False if already exists
        """
        if self.secrets_file.exists():
            logger.info("Secrets store already exists")
            return False
        
        # Create empty encrypted store
        with _secrets_lock:
            # Generate initial encryption key if not exists
            if not self.key_manager.has_key():
                self.key_manager.generate_key()
            
            # Create empty encrypted data
            empty_data = {}
            encrypted = self._encrypt_data(empty_data)
            
            # Atomic write
            temp_file = self.secrets_file.with_suffix('.tmp')
            # Ensure parent directory exists
            temp_file.parent.mkdir(parents=True, exist_ok=True)
            temp_file.write_bytes(encrypted)
            temp_file.replace(self.secrets_file)
            
            logger.info(f"Initialized secrets store: {self.secrets_file}")
            return True
    
    def set_secret(self, key: str, value: str) -> None:
        """
        Set a secret value.
        
        Args:
            key: Secret key name
            value: Secret value (will be encrypted)
        """
        if not self.secrets_file.exists():
            raise ValueError("Secrets store not initialized. Run 'devforge secrets init' first.")
        
        with _secrets_lock:
            # Read and decrypt existing secrets
            data = self._read_secrets()
            
            # Update secret
            data[key] = value
            
            # Encrypt and write back
            encrypted = self._encrypt_data(data)
            temp_file = self.secrets_file.with_suffix('.tmp')
            temp_file.write_bytes(encrypted)
            temp_file.replace(self.secrets_file)
            
            logger.debug(f"Set secret: {key}")
    
    def get_secret(self, key: str) -> Optional[str]:
        """
        Get a secret value.
        
        Args:
            key: Secret key name
            
        Returns:
            Secret value or None if not found
        """
        if not self.secrets_file.exists():
            return None
        
        with _secrets_lock:
            data = self._read_secrets()
            return data.get(key)
    
    def list_secrets(self) -> List[str]:
        """
        List all secret keys.
        
        Returns:
            List of secret key names
        """
        if not self.secrets_file.exists():
            return []
        
        with _secrets_lock:
            data = self._read_secrets()
            return sorted(data.keys())
    
    def inject_runtime_env(self, output_file: Optional[Path] = None) -> Path:
        """
        Inject secrets into runtime environment file.
        
        Args:
            output_file: Output file path (default: .env.secrets)
            
        Returns:
            Path to generated environment file
        """
        if output_file is None:
            output_file = self.project_root / ".env.secrets"
        
        if not self.secrets_file.exists():
            logger.warning("No secrets store found. Creating empty .env.secrets")
            output_file.write_text("# No secrets configured\n")
            return output_file
        
        with _secrets_lock:
            data = self._read_secrets()
            
            # Generate environment file
            lines = ["# Auto-generated secrets file - DO NOT COMMIT\n"]
            lines.append("# This file is generated from encrypted .secrets.devforge\n")
            lines.append("# Generated by DevForge Secrets Manager\n\n")
            
            for key, value in sorted(data.items()):
                # Escape value for shell
                escaped_value = value.replace('"', '\\"').replace('$', '\\$')
                lines.append(f'{key}="{escaped_value}"\n')
            
            # Atomic write
            temp_file = output_file.with_suffix('.tmp')
            # Ensure parent directory exists
            temp_file.parent.mkdir(parents=True, exist_ok=True)
            temp_file.write_text(''.join(lines))
            temp_file.replace(output_file)
            
            logger.info(f"Injected secrets to: {output_file}")
            return output_file
    
    def _read_secrets(self) -> Dict[str, str]:
        """Read and decrypt secrets from file."""
        if not self.secrets_file.exists():
            return {}
        
        encrypted_data = self.secrets_file.read_bytes()
        return self._decrypt_data(encrypted_data)
    
    def _encrypt_data(self, data: Dict[str, str]) -> bytes:
        """Encrypt data dictionary."""
        json_data = json.dumps(data).encode('utf-8')
        key = self.key_manager.get_key()
        fernet = Fernet(key)
        return fernet.encrypt(json_data)
    
    def _decrypt_data(self, encrypted_data: bytes) -> Dict[str, str]:
        """Decrypt data to dictionary."""
        key = self.key_manager.get_key()
        fernet = Fernet(key)
        decrypted = fernet.decrypt(encrypted_data)
        return json.loads(decrypted.decode('utf-8'))


class _KeyManager:
    """Manages encryption key storage with platform-specific backends."""
    
    def __init__(self):
        """Initialize key manager."""
        self.system = platform.system().lower()
        self.devforge_dir = Path.home() / ".devforge"
        self.key_file = self.devforge_dir / "key"
        self.devforge_dir.mkdir(exist_ok=True, mode=0o700)
    
    def has_key(self) -> bool:
        """Check if encryption key exists."""
        if self.system == "windows":
            return self._has_windows_key() or self.key_file.exists()
        elif self.system == "darwin":
            return self._has_macos_key() or self.key_file.exists()
        else:  # Linux
            return self.key_file.exists()
    
    def get_key(self) -> bytes:
        """
        Get encryption key.
        
        Returns:
            Fernet key bytes
        """
        if self.system == "windows":
            key = self._get_windows_key()
            if key:
                return key
        elif self.system == "darwin":
            key = self._get_macos_key()
            if key:
                return key
        
        # Fallback to file-based storage
        if self.key_file.exists():
            return self.key_file.read_bytes()
        
        raise ValueError("Encryption key not found. Run 'devforge secrets init' first.")
    
    def generate_key(self) -> bytes:
        """
        Generate and store new encryption key.
        
        Returns:
            Generated Fernet key bytes
        """
        key = Fernet.generate_key()
        
        # Try platform-specific storage first
        if self.system == "windows":
            if self._store_windows_key(key):
                return key
        elif self.system == "darwin":
            if self._store_macos_key(key):
                return key
        
        # Fallback to file storage
        self.key_file.write_bytes(key)
        self.key_file.chmod(0o600)  # Read/write for owner only
        logger.info(f"Stored encryption key in: {self.key_file}")
        return key
    
    def _has_windows_key(self) -> bool:
        """Check for key in Windows Credential Manager."""
        try:
            import win32cred
            try:
                win32cred.CredRead("DevForge:EncryptionKey", 1)
                return True
            except Exception:
                return False
        except ImportError:
            return False
    
    def _get_windows_key(self) -> Optional[bytes]:
        """Get key from Windows Credential Manager."""
        try:
            import win32cred
            try:
                cred = win32cred.CredRead("DevForge:EncryptionKey", 1)
                return cred['CredentialBlob']
            except Exception:
                return None
        except ImportError:
            return None
    
    def _store_windows_key(self, key: bytes) -> bool:
        """Store key in Windows Credential Manager."""
        try:
            import win32cred
            win32cred.CredWrite({
                'Type': 1,  # Generic credential
                'TargetName': 'DevForge:EncryptionKey',
                'UserName': 'DevForge',
                'CredentialBlob': key,
                'Comment': 'DevForge secrets encryption key',
                'Persist': 2  # Local machine
            }, 0)
            logger.info("Stored encryption key in Windows Credential Manager")
            return True
        except ImportError:
            logger.debug("pywin32 not available, using file storage")
            return False
        except Exception as e:
            logger.warning(f"Failed to store in Credential Manager: {e}, using file storage")
            return False
    
    def _has_macos_key(self) -> bool:
        """Check for key in macOS Keychain."""
        try:
            import subprocess
            result = subprocess.run(
                ['security', 'find-generic-password', '-s', 'DevForge:EncryptionKey', '-w'],
                capture_output=True,
                text=True
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def _get_macos_key(self) -> Optional[bytes]:
        """Get key from macOS Keychain."""
        try:
            import subprocess
            result = subprocess.run(
                ['security', 'find-generic-password', '-s', 'DevForge:EncryptionKey', '-w'],
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                return result.stdout.strip().encode('utf-8')
            return None
        except Exception:
            return None
    
    def _store_macos_key(self, key: bytes) -> bool:
        """Store key in macOS Keychain."""
        try:
            import subprocess
            # Delete existing if present
            subprocess.run(
                ['security', 'delete-generic-password', '-s', 'DevForge:EncryptionKey'],
                capture_output=True,
                stderr=subprocess.DEVNULL
            )
            
            # Store new key
            process = subprocess.Popen(
                ['security', 'add-generic-password', '-s', 'DevForge:EncryptionKey',
                 '-a', 'DevForge', '-w', key.decode('utf-8'), '-U'],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            process.communicate()
            
            if process.returncode == 0:
                logger.info("Stored encryption key in macOS Keychain")
                return True
            return False
        except Exception as e:
            logger.warning(f"Failed to store in Keychain: {e}, using file storage")
            return False

